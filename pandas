2877. Create a DataFrame from List

import pandas as pd

def createDataframe(student_data: List[List[int]]):
    columns = ['student_id', 'age']
    df = pd.DataFrame(student_data, columns = columns)
    return df


-- 262. Trips and Users

with a as(
select t. id, t.client_id, t.driver_id, t.city_id, t.status, t.request_at    
from Trips as t
left join users as u
on t.client_id = u.users_id 
left join users as u1
on t.driver_id = u1.users_id 
where u.banned = 'No' and u1.banned = 'No')

select request_at as Day,
round(sum(if(status='completed', 0, 1))/count(status),2) as 'Cancellation Rate'
from a
where request_at between '2013-10-01' and '2013-10-03'
group by request_at

-- another way

select request_at as Day,
round(sum(if(status='completed', 0, 1))/count(status),2) as 'Cancellation Rate'
from Trips
where request_at between '2013-10-01' and '2013-10-03'
and client_id not in (select client_id from Trips as t left join users as u on t. client_id = u. users_id where u.banned = 'Yes')
and driver_id not in (select driver_id from Trips as t left join users as u on t. driver_id = u. users_id where u.banned = 'Yes')
group by request_at

-- simplier way: since we already know the users fields are matching

select request_at as Day,
round(sum(if(status='completed', 0, 1))/count(status),2) as 'Cancellation Rate'
from Trips
where request_at between '2013-10-01' and '2013-10-03'
and client_id not in (select users_id from users where banned = 'Yes')
and driver_id not in (select users_id from users where banned = 'Yes')
group by request_at


-- 601. Human Traffic of Stadium
-- use where first, id - row_number() is consecutive number of people > 100
-- be aware consecutive is consecutive id, not vistit date 

with a as(select *,  id - row_number()over(order by id asc) as rnk
from stadium
where people>=100)

select id, visit_date, people
from a
where rnk in (select rnk from a group by rnk having count(rnk)>=3)

--570. Managers with at Least 5 Direct Reports: notice! id in, not managerId in ()

select name
from Employee
where id in
(select managerId from Employee group by managerId having  count(managerId) >= 5)

-- pandas
import pandas as pd
def find_managers(employee: pd.DataFrame) -> pd.DataFrame:
    # add a new column called count
    managers = employee.groupby(['managerId'])['managerId'].agg(['count']).reset_index()
    managers = managers.loc[managers['count']>= 5, ['managerId']]
    new_df = employee.loc[employee['id'].isin(managers['managerId']), ['name']]
    # new_df = employee[employee['id'].isin(managers['managerId'])][['name']]
    return new_df

-- 1934. Confirmation Rate
--  mean = sum/count can also be replaced into: round(avg(if(c.action="confirmed",1,0)),2)

select s.user_id, round(sum(if(c.action= 'confirmed', 1,0))/count(s.user_id),2) as confirmation_rate
from Signups as s
left join Confirmations as c
on s.user_id = c.user_id
group by s.user_id

pandas: need to reste_index after group by

    confirmations['confirmation_rate'] = confirmations['action'].apply(lambda x:1 if x == 'confirmed' else 0)
    avg_conf = confirmations[['user_id','confirmation_rate']].groupby('user_id')['confirmation_rate'].mean().round(2).reset_index()
    output = pd.merge(signups['user_id'],avg_conf,how='left').fillna(0)  
    return output

-- 1193. Monthly Transactions I
-- can also use: DATE_FORMAT(trans_date, '%Y-%m')

select left(trans_date, 7) as month, country,
count(id) as trans_count,
sum(if(state ='approved', 1, 0)) as approved_count,
sum(amount) as trans_total_amount,
sum(if(state ='approved', amount, 0)) as approved_total_amount
from Transactions
group by left(trans_date, 7), country

pandas:

def monthly_transactions(transactions: pd.DataFrame) -> pd.DataFrame:
    transactions['month'] = transactions.apply(lambda x: x['trans_date'].strftime("%Y-%m"), axis=1)
    # why cannot 0, must be? since we will use approved_count below, count a column will include 0, if we set to null, null won't be included 
    transactions['approved_amount'] = transactions.apply(lambda x: x['amount'] if x['state'] == 'approved' else np.nan, axis =1 ) 
    # we we need dropna here, since we wil have NULL contry in the test section, we want keep it as null in the amount summary
    return transactions.groupby(['month','country'],as_index=False,dropna=False).agg(
                            trans_count=('id', 'count'),                            
                            approved_count=('approved_amount', 'count'),
                            trans_total_amount=('amount', 'sum'),
                            approved_total_amount=('approved_amount', 'sum')
                            )


1174. Immediate Food Delivery II (note: cannot use min(date) at first, then count, those steps will mismatch min(date) to order date (first show date), will reduce the count of (daye same) 

select round(100*sum(if(order_date = customer_pref_delivery_date, 1,0))/count(distinct customer_id),2) as immediate_percentage
from Delivery
where (customer_id, order_date)
in (select customer_id, min(order_date) as min_date
from Delivery group by customer_id )
